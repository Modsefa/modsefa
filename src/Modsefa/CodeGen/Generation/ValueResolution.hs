{-|
Module      : Modsefa.CodeGen.Generation.ValueResolution
Description : Plutus Tx expression generation for Modsefa FieldValueIR.
Copyright   : (c) The Modsefa Project, 2025
License     : Apache-2.0
Maintainer  : nrmeyer@ptrx.xyz
Stability   : experimental
Portability : GHC (requires TemplateHaskell)

This module provides Template Haskell (TH) functions to generate Plutus Tx
code expressions ('Language.Haskell.TH.Exp') that correspond to the different
constructors of 'Modsefa.Core.IR.Types.FieldValueIR'. These generated expressions
are used within the validator logic (generated by 'Modsefa.CodeGen.Generation.Logic')
to compute or retrieve values needed for field assignments or constraint checks at runtime.

It handles translating IR concepts like 'FromStateField', 'CurrentTimeIR', arithmetic operations,
and literals into their on-chain Plutus Tx equivalents. It also includes specific helpers
for generating expressions that resolve to Plutus 'Value' and 'Address' types.
-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | PlutusTx Expression Generation from FieldValueIR
module Modsefa.CodeGen.Generation.ValueResolution
  ( generateValueExpression
  , generatePlutusValueExpression
  , generateAddressExpression
  ) where

import Data.Text (unpack, Text)
import Language.Haskell.TH
  ( Exp, Q, conE, conT, integerL, litE, mkName, stringL, varE
  )
import Prelude (Bool(..), String, error, otherwise, show, ($), (++), (==))

import PlutusLedgerApi.V3
  ( Extended(Finite), Interval(Interval), LowerBound(LowerBound)
  , POSIXTime, ScriptContext(..)
  , adaSymbol, adaToken, scriptContextTxInfo, singleton
  , txInfoValidRange
  )
import PlutusTx.Builtins.HasOpaque (stringToBuiltinString)
import PlutusTx.Prelude
  ( Integer, Maybe(..), appendString, divide, traceError, (+), (-), (*)
  )

import Modsefa.Core.IR.Types (ActionIR(..), FieldValueIR(..), OperationIR(..))


-- | (Internal) Finds the 'ReferenceOpIR' corresponding to a given label ('Text')
-- within the list of operations in an 'ActionIR'. Used by 'generateValueExpression'
-- to find the state name associated with a 'FromStateField' label.
findRefOp :: Text -> ActionIR -> Maybe OperationIR
findRefOp label action = go (actionIROperations action)
  where
    go [] = Nothing
    go (op@(ReferenceOpIR _ l) : ops)
        | unpack l Prelude.== unpack label = Just op
        | otherwise = go ops
    go (_:ops) = go ops

-- | Generates a Plutus Tx expression ('Q Exp') that resolves a 'FieldValueIR'
-- to its corresponding on-chain value at runtime. Requires the parent 'ActionIR'
-- context to resolve 'FromStateField' references.
generateValueExpression :: ActionIR -- ^ The parent action IR containing potential 'ReferenceOpIR's.
                        -> FieldValueIR -- ^ The IR value specification to generate code for.
                        -> Q Exp -- ^ TH computation returning the Plutus Tx expression.
generateValueExpression action (FromStateField label fieldName) =
    let stateTypeName = case findRefOp label action of
            Just (ReferenceOpIR sName _) -> conT (mkName (unpack sName))
            _ -> error $ "CodeGen (generateValueExpression): Could not find 'Reference' operation with label '" Prelude.++ unpack label Prelude.++ "'"
        fieldAccessor = varE (mkName (unpack fieldName))
        datumVarName = mkName ("ref_" Prelude.++ unpack label)
    in
    [|
        case $(varE datumVarName) :: Maybe $stateTypeName of
            Just refDatum -> $(fieldAccessor) refDatum
            Nothing -> traceError (stringToBuiltinString ("CodeGen: Pre-resolved reference input failed for label: " :: String)
                                   `appendString` stringToBuiltinString ($(litE (stringL (unpack label))) :: String))
    |]
-- Arithmetic Operations: Recursively generate expressions for operands and combine with Plutus Tx operators.
generateValueExpression action (AddValueIR v1 v2) = [| $(generateValueExpression action v1) + $(generateValueExpression action v2) |]
generateValueExpression action (SubtractValueIR v1 v2) = [| $(generateValueExpression action v1) - $(generateValueExpression action v2) |]
generateValueExpression action (MultiplyValueIR v1 v2) = [| $(generateValueExpression action v1) * $(generateValueExpression action v2) |]
generateValueExpression action (DivideValueIR v1 v2) = [| $(generateValueExpression action v1) `PlutusTx.Prelude.divide` $(generateValueExpression action v2) |]
generateValueExpression _ CurrentTimeIR =
    [|
        -- Helper function defined within the generated code.
        let
            getTxValidationStartTime :: ScriptContext -> POSIXTime
            getTxValidationStartTime sc =
                let (Interval from _) = txInfoValidRange (scriptContextTxInfo sc)
                in case from of
                    LowerBound (Finite t) True -> t
                    _                          -> traceError "Validity range must have an inclusive start time"
        in
            -- Apply the helper to the current context 'ctx' (assumed in scope).
            getTxValidationStartTime ctx
    |]
generateValueExpression _ (FromInt i) = litE (integerL i)
generateValueExpression _ (FromEnum _ constructorName) = conE (mkName (unpack constructorName))
generateValueExpression _ (FromActionParam name) =
    error $ "generateValueExpression: Cannot resolve FromActionParam '" Prelude.++ unpack name Prelude.++ "' on-chain."
generateValueExpression _ (FromInputField name) =
    error $ "generateValueExpression: Cannot resolve FromInputField '" Prelude.++ unpack name Prelude.++ "' on-chain (needs input datum)."

-- | Generates a Plutus Tx expression ('Q Exp') that resolves a 'FieldValueIR'
-- specifically into a Plutus 'Value' (typically for transaction outputs or comparisons).
-- Handles integer values by converting them to Lovelace 'Value'.
-- Assumes arithmetic operations on 'Value' apply primarily to the Lovelace component if mixing types.
generatePlutusValueExpression :: ActionIR -> FieldValueIR -> Q Exp
generatePlutusValueExpression action fv = case fv of
    FromInt i ->
        [| singleton adaSymbol adaToken $(litE (integerL i)) |]
    FromStateField _ _ ->
        [| let intVal :: Integer = $(generateValueExpression action fv)
           in singleton adaSymbol adaToken intVal
        |]
    AddValueIR v1 v2 ->
        [| $(generatePlutusValueExpression action v1) + $(generatePlutusValueExpression action v2) |]
    SubtractValueIR v1 v2 ->
         [| $(generatePlutusValueExpression action v1) - $(generatePlutusValueExpression action v2) |]
    MultiplyValueIR v1 v2 ->
         [| let val1 :: Integer = $(generateValueExpression action v1)
                val2 :: Integer = $(generateValueExpression action v2)
            in singleton adaSymbol adaToken (val1 * val2)
         |]
    DivideValueIR v1 v2 ->
         [| let val1 :: Integer = $(generateValueExpression action v1)
                val2 :: Integer = $(generateValueExpression action v2)
            in singleton adaSymbol adaToken (val1 `PlutusTx.Prelude.divide` val2)
         |]
    _ -> error $ "generatePlutusValueExpression: Unsupported FieldValueIR for Plutus Value: " Prelude.++ show fv

-- | Generates a Plutus Tx expression ('Q Exp') that resolves a 'FieldValueIR'
-- specifically into a Plutus 'Address'.
-- Currently only supports 'FromStateField' where the field type is 'Address'.
generateAddressExpression :: ActionIR -> FieldValueIR -> Q Exp
generateAddressExpression action fv = case fv of
    -- Address comes from a field in a referenced state datum.
    FromStateField _ _ ->
        -- Use generateValueExpression, assuming the field's type is indeed Address.
        -- Type checking relies on the Haskell type checker where this Exp is spliced.
        generateValueExpression action fv
    -- Action parameters cannot be resolved on-chain this way.
    FromActionParam name ->
        error $ "generateAddressExpression: Cannot resolve Address FromActionParam '" Prelude.++ unpack name Prelude.++ "' on-chain."
    _ -> error $ "generateAddressExpression: Unsupported FieldValueIR for Plutus Address: " Prelude.++ show fv