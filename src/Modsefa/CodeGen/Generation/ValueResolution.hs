{-|
Module      : Modsefa.CodeGen.Generation.ValueResolution
Description : Plutus Tx expression generation for Modsefa FieldValueIR.
Copyright   : (c) The Modsefa Project, 2025
License     : Apache-2.0
Maintainer  : nrmeyer@ptrx.xyz
Stability   : experimental
Portability : GHC (requires TemplateHaskell)

This module provides Template Haskell (TH) functions to generate Plutus Tx
code expressions ('Language.Haskell.TH.Exp') that correspond to the different
constructors of 'Modsefa.Core.IR.Types.FieldValueIR'. These generated expressions
are used within the validator logic (generated by 'Modsefa.CodeGen.Generation.Logic')
to compute or retrieve values needed for field assignments or constraint checks at runtime.

It handles translating IR concepts like 'FromStateField', 'CurrentTimeIR', arithmetic operations,
and literals into their on-chain Plutus Tx equivalents. It also includes specific helpers
for generating expressions that resolve to Plutus 'Value' and 'Address' types.
-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | PlutusTx Expression Generation from FieldValueIR
module Modsefa.CodeGen.Generation.ValueResolution
  ( generateValueExpression
  , generatePlutusValueExpression
  , generateAddressExpression
  ) where

import Data.Text (unpack, Text)
import Language.Haskell.TH
  ( Exp, Q, Type, conE, conT, integerL, litE, mkName, stringL, varE
  )
import Prelude (Bool(..), String, error, fail, return, show, ($), (++), (==))

import PlutusLedgerApi.V3
  ( Extended(Finite), Interval(Interval), LowerBound(LowerBound), POSIXTime
  , ScriptContext(..), adaSymbol, adaToken, scriptContextTxInfo, singleton
  , txInfoValidRange
  )
import PlutusTx.Builtins.HasOpaque (stringToBuiltinString)
import PlutusTx.Prelude
  ( Integer, Maybe(..), appendString, divide, traceError, (+), (-), (*)
  )

import Modsefa.Core.IR.Types
    ( ActionIR(..), FieldValueIR(..), OperationIR(..), StateInfoIR(..)
    )


-- ============================================================================
-- * Main Expression Generators
-- ============================================================================

-- | Generates a Plutus Tx expression ('Q Exp') that resolves a 'FieldValueIR'
-- to its corresponding on-chain value at runtime. Requires the parent 'ActionIR'
-- context to resolve 'FromStateField' references.
generateValueExpression :: [StateInfoIR] -- ^ Mapping between state type and datum type
                        -> ActionIR -- ^ The parent action IR containing potential 'ReferenceOpIR's.
                        -> FieldValueIR -- ^ The IR value specification to generate code for.
                        -> Q Exp -- ^ TH computation returning the Plutus Tx expression.
generateValueExpression _registry _action (FromActionParam paramName) =
  [| $(varE (mkName (unpack paramName))) |]
generateValueExpression _registry _action (FromInt n) =
  [| $(litE (integerL n)) |]
generateValueExpression _registry _action (FromEnum _typeName conName) =
  -- Simplified Enum handling: assumes constructor is in scope.
  [| $(conE (mkName (unpack conName))) |]
generateValueExpression _registry _action CurrentTimeIR =
  [|
        -- Helper function defined within the generated code.
        let
            getTxValidationStartTime :: ScriptContext -> POSIXTime
            getTxValidationStartTime sc =
                let (Interval from _) = txInfoValidRange (scriptContextTxInfo sc)
                in case from of
                    LowerBound (Finite t) True -> t
                    _                          -> traceError "Validity range must have an inclusive start time"
        in
            -- Apply the helper to the current context 'ctx' (assumed in scope).
            getTxValidationStartTime ctx
    |]
generateValueExpression registry action (AddValueIR v1 v2) =
  [| $(generateValueExpression registry action v1) PlutusTx.Prelude.+ $(generateValueExpression registry action v2) |]
generateValueExpression registry action (SubtractValueIR v1 v2) =
  [| $(generateValueExpression registry action v1) PlutusTx.Prelude.- $(generateValueExpression registry action v2) |]
generateValueExpression registry action (MultiplyValueIR v1 v2) =
  [| $(generateValueExpression registry action v1) PlutusTx.Prelude.* $(generateValueExpression registry action v2) |]
generateValueExpression registry action (DivideValueIR v1 v2) =
  [| $(generateValueExpression registry action v1) `PlutusTx.Prelude.divide` $(generateValueExpression registry action v2) |]
generateValueExpression registry action (FromStateField label field) = do
    stateName <- getStateNameForLabel action label
    let datumTypeQ = lookupDatumType registry stateName
    let refVarName = mkName ("ref_" Prelude.++ unpack label)
        fieldNameName = mkName (unpack field)

    [| case $(varE refVarName) :: Maybe $datumTypeQ of
        Just refDatum -> $(varE fieldNameName) refDatum
        Nothing -> traceError (stringToBuiltinString ("Reference not found for field access: " :: String)
                                   `appendString` stringToBuiltinString ($(litE (stringL (unpack label))) :: String))
     |]
generateValueExpression _registry _action (FromInputField fieldName) =
   [| $(varE (mkName (unpack fieldName))) inputDatum |]

-- | Generates a Plutus Tx expression that evaluates to a 'PlutusLedgerApi.V3.Value'.
-- Handles creation of Value from asset classes and amounts, potentially derived
-- from other fields or parameters.
generatePlutusValueExpression :: [StateInfoIR] -> ActionIR -> FieldValueIR -> Q Exp
generatePlutusValueExpression registry action fv = case fv of
    FromInt i ->
        [| singleton adaSymbol adaToken $(litE (integerL i)) |]
    FromStateField _ _ ->
        [| let intVal :: Integer = $(generateValueExpression registry action fv)
           in singleton adaSymbol adaToken intVal
        |]
    AddValueIR v1 v2 ->
        [| $(generatePlutusValueExpression registry action v1) + $(generatePlutusValueExpression registry action v2) |]
    SubtractValueIR v1 v2 ->
         [| $(generatePlutusValueExpression registry action v1) - $(generatePlutusValueExpression registry action v2) |]
    MultiplyValueIR v1 v2 ->
         [| let val1 :: Integer = $(generateValueExpression registry action v1)
                val2 :: Integer = $(generateValueExpression registry action v2)
            in singleton adaSymbol adaToken (val1 * val2)
         |]
    DivideValueIR v1 v2 ->
         [| let val1 :: Integer = $(generateValueExpression registry action v1)
                val2 :: Integer = $(generateValueExpression registry action v2)
            in singleton adaSymbol adaToken (val1 `PlutusTx.Prelude.divide` val2)
         |]
    _ -> error $ "generatePlutusValueExpression: Unsupported FieldValueIR for Plutus Value: " Prelude.++ show fv

-- | Generates a Plutus Tx expression ('Q Exp') that resolves a 'FieldValueIR'
-- specifically into a Plutus 'Address'.
-- Currently only supports 'FromStateField' where the field type is 'Address'.
generateAddressExpression :: [StateInfoIR] -> ActionIR -> FieldValueIR -> Q Exp
generateAddressExpression registry action fv = case fv of
    -- Address comes from a field in a referenced state datum.
    FromStateField _ _ ->
        -- Use generateValueExpression, assuming the field's type is indeed Address.
        -- Type checking relies on the Haskell type checker where this Exp is spliced.
        generateValueExpression registry action fv
    -- Action parameters cannot be resolved on-chain this way.
    FromActionParam name ->
        error $ "generateAddressExpression: Cannot resolve Address FromActionParam '" Prelude.++ unpack name Prelude.++ "' on-chain."
    _ -> error $ "generateAddressExpression: Unsupported FieldValueIR for Plutus Address: " Prelude.++ show fv

-- ============================================================================
-- * Internal Helpers
-- ============================================================================

-- | (Internal) Looks up the datum type name ('Q Type') for a given state tag
-- | from the 'StateInfoIR' registry.
lookupDatumType :: [StateInfoIR] -> Text -> Q Type
lookupDatumType registry stateName = do
    let find p (x:xs) = if p x then Just x else find p xs
        find _ [] = Nothing
    case find (\info -> stateInfoName info == stateName) registry of
        Just info -> conT (mkName (unpack (stateInfoDatumName info)))
        Nothing   -> fail $ "CodeGen Error: State '" Prelude.++ unpack stateName Prelude.++ "' not found in app registry."

-- | (Internal) Finds the state name ('Q Text') associated with a given
-- | 'Let' label by searching the action's 'ReferenceOpIR' operations.
getStateNameForLabel :: ActionIR -> Text -> Q Text
getStateNameForLabel action label = do
    let ops = actionIROperations action
        find p (x:xs) = if p x then Just x else find p xs
        find _ [] = Nothing
        isLabel l (ReferenceOpIR _ lbl) = l == lbl
        isLabel _ _ = False
    case find (isLabel label) ops of
        Just (ReferenceOpIR stateName _) -> return stateName
        _ -> fail $ "CodeGen Error: Label '" Prelude.++ unpack label Prelude.++ "' not found in action."