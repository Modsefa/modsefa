{-|
Module      : Modsefa.CodeGen.Generation.Constraints
Description : Plutus Tx code generation for Modsefa constraints from IR.
Copyright   : (c) The Modsefa Project, 2025
License     : Apache-2.0
Maintainer  : nrmeyer@ptrx.xyz
Stability   : experimental
Portability : GHC (requires TemplateHaskell)

This module uses Template Haskell (TH) to generate Plutus Tx code fragments
('Language.Haskell.TH.Exp') that implement the on-chain validation logic
for various constraints defined in the Modsefa Intermediate Representation
('Modsefa.Core.IR.Types.ConstraintIR').

The main function, 'generateConstraintChecksForAction', takes an 'ActionIR' and
produces a single TH expression that combines the checks for all constraints
within that action using boolean AND ('PlutusTx.Prelude.&&'). Individual helper
functions generate the code for specific constraint types like 'MustBeSignedBy',
'MustAddToAggregateState', 'MustWithdrawFromAggregateState', and 'MustCheckInstance'.
-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-unused-local-binds #-}
{-# OPTIONS_GHC -Wno-unused-matches #-}

-- | Constraint validation code generation from the IR
--
-- This module generates Template Haskell code for validating constraints
-- within validator functions, using the backend-agnostic IR.
module Modsefa.CodeGen.Generation.Constraints
  ( generateConstraintChecksForAction
  ) where

import Control.Monad (MonadFail(fail))
import Data.Proxy (Proxy(Proxy))
import Data.Text (Text, unpack)
import Language.Haskell.TH
  ( Exp(AppE, ConE, SigE, VarE), Q, Type(..), conT, listE, litE, lookupTypeName
  , mkName, stringL, varE
  )
import Prelude (String, return, (++), ($))

import GeniusYield.Types (assetClassToPlutus)
import PlutusLedgerApi.V1.Value (AssetClass(AssetClass), valueOf)
import PlutusLedgerApi.V3
  ( Address(..), Credential(ScriptCredential), Datum(..), OutputDatum(..)
  , PubKeyHash, TxInInfo, TxOut, Value(..), scriptContextTxInfo, txInfoInputs
  , txInfoOutputs, txInfoReferenceInputs, txInInfoResolved, txInfoSignatories
  , txOutDatum, txOutAddress, txOutValue
  )
import PlutusTx (fromBuiltinData)
import PlutusTx.Builtins.HasOpaque (stringToBuiltinString)
import PlutusTx.Prelude
  ( Bool(..), Maybe(..), all, any, appendString, elem, emptyString
  , find, id, map, not, traceError, traceIfFalse, (++), (==), (&&), (>)
  , (>=)
  )

import Modsefa.Core.Foundation
  ( StateIdentifier(AggregateAsset), StateRepresentable(stateIdentifier)
  )
import Modsefa.Core.IR.Types
  ( ActionIR(..), ConstraintIR(..), FieldValueIR(FromActionParam)
  , InstanceCheckIR(..), PubKeyHashIR(..)
  )

import Modsefa.CodeGen.Generation.InstanceChecks (generateAddressMatchesParamCheck)
import Modsefa.CodeGen.Generation.ValueResolution
  ( generateAddressExpression, generatePlutusValueExpression
  )


-- ============================================================================
-- 1. MAIN ENTRY POINT
-- ============================================================================

-- | Generates a Plutus Tx boolean expression ('Q Exp') that performs all necessary
-- on-chain validation checks for the constraints specified within a given 'ActionIR'.
-- It combines the individual checks generated by 'generateSingleConstraintCheck' using 'PlutusTx.Prelude.all'.
generateConstraintChecksForAction :: ActionIR -- ^ The IR representation of the action containing the constraints.
                                  -> Q Exp -- ^ TH computation returning the combined constraint check expression.
generateConstraintChecksForAction action = do
  -- Generate a list of TH expressions, one for each constraint check.
  let constraintChecks = map (generateSingleConstraintCheck action) (actionIRConstraints action)
  -- Combine all individual check expressions into a single expression: all id [check1, check2, ...]
  [| PlutusTx.Prelude.all PlutusTx.Prelude.id $(listE constraintChecks) |]

-- ============================================================================
-- 2. INDIVIDUAL CONSTRAINT GENERATION
-- ============================================================================

-- | (Internal) Generates the Plutus Tx validation logic ('Q Exp') for a single `ConstraintIR`.
-- Dispatches to specific helper functions based on the constraint constructor.
generateSingleConstraintCheck :: ActionIR -- ^ The parent action IR (needed for context, e.g., resolving 'FieldValueIR').
                              -> ConstraintIR -- ^ The specific constraint IR to generate code for.
                              -> Q Exp -- ^ TH computation returning the validation expression for this constraint.
-- Dispatch based on constraint type:
generateSingleConstraintCheck _action (MustBeSignedBy pkhSource) =
  generateMustBeSignedByCheck pkhSource
-- MustSpendActionParam is checked off-chain during transaction building, not in the validator.
generateSingleConstraintCheck _action (MustSpendActionParamIR _) =
  [| True |]
generateSingleConstraintCheck action (MustAddToAggregateStateIR stateName valueIR) =
  generateAddToAggregateCheck action stateName valueIR
generateSingleConstraintCheck action (MustWithdrawFromAggregateStateIR stateName valueIR addressIR) =
  generateWithdrawFromAggregateCheck action stateName valueIR addressIR
generateSingleConstraintCheck _action (MustCheckInstance instanceCheck) =
  generateInstanceCheck instanceCheck

-- ============================================================================
-- 3. SPECIFIC CONSTRAINT VALIDATORS
-- ============================================================================

-- | (Internal) Generates the Plutus Tx logic ('Q Exp') for the 'MustBeSignedBy' constraint.
generateMustBeSignedByCheck :: PubKeyHashIR -- ^ The source of the required signer's public key hash.
                            -> Q Exp -- ^ TH computation returning the signature check expression.
generateMustBeSignedByCheck (FromActionParamPKH _paramName) =
  -- Note: We can't validate this on-chain as the action parameter value isn't
  -- available to the script.
  [| True |]
generateMustBeSignedByCheck (FromStateFieldPKH stateName fieldName) = do
  let stateTypeName = mkName (unpack stateName)
  let fieldAccessorName = mkName (unpack fieldName)

  [| let
        signatories = PlutusLedgerApi.V3.txInfoSignatories (scriptContextTxInfo ctx)
        -- The required signer could be in a state being spent OR just referenced
        allInputs = txInfoInputs (scriptContextTxInfo ctx) PlutusTx.Prelude.++ txInfoReferenceInputs (scriptContextTxInfo ctx)

        -- A helper to search a list of inputs for the state and extract the PKH
        findRequiredSigner :: [TxInInfo] -> Maybe PubKeyHash
        findRequiredSigner [] = Nothing
        findRequiredSigner (txInInfo : rest) =
          case PlutusLedgerApi.V3.txOutDatum (PlutusLedgerApi.V3.txInInfoResolved txInInfo) of
            OutputDatum datumData ->
              case (PlutusTx.fromBuiltinData (getDatum datumData) :: Maybe $(conT stateTypeName)) of
                Just stateData -> Just ($(varE fieldAccessorName) stateData)
                Nothing -> findRequiredSigner rest -- Datum was wrong type
            _ -> findRequiredSigner rest -- No inline datum

     in case findRequiredSigner allInputs of
          Just requiredSigner -> requiredSigner `elem` signatories
          Nothing -> traceIfFalse "Constraint failed: Could not find state to extract required signer" False
   |]

-- | (Internal) Generates the Plutus Tx logic ('Q Exp') for an 'InstanceCheckIR'.
-- Delegates to specific generators based on the check type.
generateInstanceCheck :: InstanceCheckIR -> Q Exp
generateInstanceCheck (AddressMatchesParamIR {amprReferenceState, amprParamName}) =
  -- Calls the helper from InstanceChecks module
  generateAddressMatchesParamCheck amprReferenceState amprParamName
generateInstanceCheck (SameAddressAsReferenceIR {scarReferenceState}) =
  let refStateTypeName = conT (mkName (unpack scarReferenceState))
  in [|
    let
      -- Helper to find the input/refInput UTXO for the reference state
      findReferenceInputOutput :: [TxInInfo] -> Maybe TxOut
      findReferenceInputOutput = PlutusTx.Prelude.find findLogic
         where
            findLogic i =
                let out = txInInfoResolved i
                in case txOutDatum out of
                    OutputDatum (Datum d) ->
                        case (fromBuiltinData d :: Maybe $refStateTypeName) of
                            Just _ -> True
                            Nothing -> False -- Wrong datum type
                    _ -> False -- No datum

      -- Find own input (assuming this check runs in a Spending context)
      ownInputAddress :: Maybe Address
      ownInputAddress = case findOwnInput ctx of
                          Just i -> Just (txOutAddress (txInInfoResolved i))
                          Nothing -> Nothing

      -- Search both regular inputs and reference inputs
      allInputs = txInfoInputs (scriptContextTxInfo ctx) PlutusTx.Prelude.++ txInfoReferenceInputs (scriptContextTxInfo ctx)
      mRefInputOutput = findReferenceInputOutput allInputs

    in case (ownInputAddress, mRefInputOutput) of
         (Just ownAddr, Just refOut) ->
            let refAddr = txOutAddress refOut
            -- Check if own input address matches the reference input address
            in traceIfFalse $(litE (stringL ("Instance Check Failed: SameAddressAsReference failed for " PlutusTx.Prelude.++ unpack scarReferenceState))) (ownAddr PlutusTx.Prelude.== refAddr)
         (Nothing, _) -> traceError "Instance Check Failed: SameAddressAsReference could not find own input"
         (_, Nothing) -> traceError ("Instance Check Failed: SameAddressAsReference could not find reference state: " `appendString` $(litE (stringL (unpack scarReferenceState))))
  |]

-- | (Internal) Generates the Plutus Tx logic ('Q Exp') for the 'MustAddToAggregateStateIR' constraint.
generateAddToAggregateCheck :: ActionIR -- ^ Parent action IR (for value resolution).
                            -> Text -- ^ Name of the aggregate state type.
                            -> FieldValueIR -- ^ IR representing the value to be added.
                            -> Q Exp -- ^ TH computation returning the validation expression.
generateAddToAggregateCheck action stateName valueIR = do
    -- Find the Plutus AssetClass associated with the aggregate state via TH.
    assetClassExpValue <- findAggregateAssetClassTH stateName
    -- Generate the TH expression for calculating the required value on-chain.
    requiredValueExp <- generatePlutusValueExpression action valueIR

    [|
      let
        theAssetClass = $(return assetClassExpValue)
        (PlutusLedgerApi.V1.Value.AssetClass (cs, tn)) = theAssetClass
        -- Evaluate the required value expression at runtime
        requiredValue = $(return requiredValueExp)

        info = scriptContextTxInfo ctx
        outputs = txInfoOutputs info

        -- Check if an output satisfies the conditions
        checkOutput :: TxOut -> Bool
        checkOutput o =
          -- Check 1: Is the output going to a script address?
          case txOutAddress o of
            Address (ScriptCredential _) _ ->
              -- Check 2: Does the output value contain at least the required amount of the specific asset?
              -- Using valueOf >= required amount derived from requiredValue. This assumes requiredValue has only one asset.
              let amountInOut = PlutusLedgerApi.V1.Value.valueOf (txOutValue o) cs tn
                  requiredAmount = PlutusLedgerApi.V1.Value.valueOf requiredValue cs tn
              in amountInOut PlutusTx.Prelude.>= requiredAmount PlutusTx.Prelude.&& requiredAmount PlutusTx.Prelude.> 0
            _ -> False -- Not a script address

        isValid = PlutusTx.Prelude.any checkOutput outputs
      in
        traceIfFalse (stringToBuiltinString ($(litE (stringL ("MustAddToAggregateState failed for state " Prelude.++ unpack stateName))) :: String)
                      `PlutusTx.Prelude.appendString` stringToBuiltinString (" - expected output with asset to a script address not found or value insufficient" :: String))
                     isValid
      |]

-- | (Internal) Generates the Plutus Tx logic ('Q Exp') for the 'MustWithdrawFromAggregateStateIR' constraint.
generateWithdrawFromAggregateCheck :: ActionIR -- ^ Parent action IR (for value/address resolution).
                                   -> Text -- ^ Name of the aggregate state type.
                                   -> FieldValueIR -- ^ IR representing the value to withdraw.
                                   -> FieldValueIR -- ^ IR representing the destination address.
                                   -> Q Exp -- ^ TH computation returning the validation expression.
generateWithdrawFromAggregateCheck action stateName valueIR addressIR = do
    assetClassExpValue <- findAggregateAssetClassTH stateName

    -- Generate the address checking function based on the addressIR source.
    destinationCheckFuncExpValue <- case addressIR of
        FromActionParam _ -> [| (\(_ :: PlutusLedgerApi.V3.Address) -> PlutusTx.Prelude.True) |]
        _ -> do
            destinationAddressExpValue <- generateAddressExpression action addressIR

            [| (\outputAddr -> outputAddr PlutusTx.Prelude.== $(return destinationAddressExpValue)) |]

    -- Value Check Logic
    valueCheckFuncExpValue <- case valueIR of
        FromActionParam _ ->

            [| \v -> PlutusLedgerApi.V1.Value.valueOf v cs tn PlutusTx.Prelude.> 0 |]
        _ -> do
            withdrawalValueExpValue <- generatePlutusValueExpression action valueIR

            [| \v ->
                 let withdrawalValue = $(return withdrawalValueExpValue)
                     withdrawalAmount = PlutusLedgerApi.V1.Value.valueOf withdrawalValue cs tn
                 in PlutusLedgerApi.V1.Value.valueOf v cs tn PlutusTx.Prelude.>= withdrawalAmount PlutusTx.Prelude.&& withdrawalAmount PlutusTx.Prelude.> 0
             |]

    [|
      let
        theAssetClass = $(return assetClassExpValue)
        (AssetClass (cs, tn)) = theAssetClass
        theDestinationCheckFunc :: PlutusLedgerApi.V3.Address -> PlutusTx.Prelude.Bool = $(return destinationCheckFuncExpValue)
        theValueCheckFunc :: PlutusLedgerApi.V3.Value -> PlutusTx.Prelude.Bool = $(return valueCheckFuncExpValue)

        info = scriptContextTxInfo ctx
        inputs = txInfoInputs info
        outputs = txInfoOutputs info

        findInput :: TxInInfo -> PlutusTx.Prelude.Bool
        findInput i =
           case txOutAddress (txInInfoResolved i) of
             Address (ScriptCredential _) _ ->
               theValueCheckFunc (txOutValue (txInInfoResolved i))
             _ -> PlutusTx.Prelude.False

        findOutput :: TxOut -> PlutusTx.Prelude.Bool
        findOutput o =
            theDestinationCheckFunc (txOutAddress o) PlutusTx.Prelude.&&
            theValueCheckFunc (txOutValue o)

        inputExists = PlutusTx.Prelude.any findInput inputs
        outputExists = PlutusTx.Prelude.any findOutput outputs
        isValid = inputExists PlutusTx.Prelude.&& outputExists
      in
        traceIfFalse (stringToBuiltinString ($(litE (stringL ("MustWithdrawFromAggregateState failed for state " Prelude.++ unpack stateName))) :: String)
                      `PlutusTx.Prelude.appendString`
                         (if PlutusTx.Prelude.not inputExists then stringToBuiltinString (" - suitable script input containing the asset not found or value insufficient" :: String)
                          else if PlutusTx.Prelude.not outputExists then stringToBuiltinString (" - suitable output to destination address not found or value insufficient" :: String)
                          else PlutusTx.Prelude.emptyString))
                     isValid
      |]

-- | (Internal) Template Haskell function to derive the Plutus 'AssetClass'
-- for an aggregate state by looking up its 'StateRepresentable' instance at compile time.
findAggregateAssetClassTH :: Text -- ^ Name of the aggregate state type.
                          -> Q Exp -- ^ TH computation returning an Exp of type AssetClass.
findAggregateAssetClassTH stateNameText = do
    -- Construct the name of the StateType alias (e.g., "TreasuryAdaState").
    let stateTypeNameStr = unpack stateNameText
    mStateAliasName <- lookupTypeName (stateTypeNameStr Prelude.++ "State")
    stateAliasName <- case mStateAliasName of
        Nothing -> fail $ "findAggregateAssetClassTH: Could not find StateType alias named '" Prelude.++ stateTypeNameStr Prelude.++ "State'. Please ensure it's defined and exported."
        Just n -> return n

    stateIdResultExp <- [| stateIdentifier (Proxy :: Proxy $(conT stateAliasName)) |]

    let stateIdCallExp = VarE 'stateIdentifier `AppE` SigE (ConE 'Proxy) (AppT (ConT ''Proxy) (ConT stateAliasName))

    [| case $(return stateIdCallExp) of
         AggregateAsset gyAC -> assetClassToPlutus gyAC
         _ -> PlutusTx.Prelude.traceError "State is not an AggregateAsset"
      |]
